#!/usr/bin/env node

// src/index.ts
import { Command as Command3 } from "commander";

// src/commands/init.ts
import chalk2 from "chalk";
import { Command } from "commander";
import { existsSync, promises as fs } from "fs";
import ora from "ora";
import path from "path";
import { execa } from "execa";
import * as z from "zod";

// src/utils/get-package-manager.ts
import { detect } from "@antfu/ni";
async function getPackageManager(targetDir) {
  const packageManager = await detect({ programmatic: true, cwd: targetDir });
  if (packageManager === "yarn@berry")
    return "yarn";
  if (packageManager === "pnpm@6")
    return "pnpm";
  if (packageManager === "bun")
    return "bun";
  return packageManager ?? "npm";
}

// src/utils/logger.ts
import chalk from "chalk";
var logger = {
  error(...args) {
    console.log(chalk.red(...args));
  },
  warn(...args) {
    console.log(chalk.yellow(...args));
  },
  info(...args) {
    console.log(chalk.cyan(...args));
  },
  success(...args) {
    console.log(chalk.green(...args));
  },
  break() {
    console.log("");
  }
};

// src/utils/handle-error.ts
function handleError(error) {
  if (typeof error === "string") {
    logger.error(error);
    process.exit(1);
  }
  if (error instanceof Error) {
    logger.error(error.message);
    process.exit(1);
  }
  logger.error("Something went wrong. Please try again.");
  process.exit(1);
}

// src/utils/templates.ts
var TAILWIND_CONFIG = `const { hairlineWidth } = require('nativewind/theme');
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: 'class',
  content: [
    './app/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
  ],
  presets: [require('nativewind/preset')],
  theme: {
    extend: {
      colors: {
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          foreground: 'hsl(var(--secondary-foreground))',
        },
        destructive: {
          DEFAULT: 'hsl(var(--destructive))',
          foreground: 'hsl(var(--destructive-foreground))',
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))',
        },
        popover: {
          DEFAULT: 'hsl(var(--popover))',
          foreground: 'hsl(var(--popover-foreground))',
        },
        card: {
          DEFAULT: 'hsl(var(--card))',
          foreground: 'hsl(var(--card-foreground))',
        },
      },
      borderWidth: {
        hairline: hairlineWidth(),
      },
      keyframes: {
        'accordion-down': {
          from: { height: '0' },
          to: { height: 'var(--radix-accordion-content-height)' },
        },
        'accordion-up': {
          from: { height: 'var(--radix-accordion-content-height)' },
          to: { height: '0' },
        },
      },
      animation: {
        'accordion-down': 'accordion-down 0.2s ease-out',
        'accordion-up': 'accordion-up 0.2s ease-out',
      },
    },
  },
  plugins: [require('tailwindcss-animate')],
};
`;
var BABEL_CONFIG = `module.exports = function (api) {
  api.cache(true);
  return {
    presets: [
      ["babel-preset-expo", { jsxImportSource: "nativewind" }],
      "nativewind/babel",
    ],
  };
};`;
var NATIVEWIND_ENV = `/// <reference types="nativewind/types" />`;
var UTILS = `import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
`;
var METRO_CONFIG = `const { getDefaultConfig } = require("expo/metro-config");
const { withNativeWind } = require('nativewind/metro');

const config = getDefaultConfig(__dirname)

module.exports = withNativeWind(config, { input: './global.css' })`;
var GLOBAL_STYLES = `@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
    :root {
        --background: 0 0% 100%;
        --foreground: 240 10% 3.9%;
        --card: 0 0% 100%;
        --card-foreground: 240 10% 3.9%;
        --popover: 0 0% 100%;
        --popover-foreground: 240 10% 3.9%;
        --primary: 240 5.9% 10%;
        --primary-foreground: 0 0% 98%;
        --secondary: 240 4.8% 95.9%;
        --secondary-foreground: 240 5.9% 10%;
        --muted: 240 4.8% 95.9%;
        --muted-foreground: 240 3.8% 46.1%;
        --accent: 240 4.8% 95.9%;
        --accent-foreground: 240 5.9% 10%;
        --destructive: 0 84.2% 60.2%;
        --destructive-foreground: 0 0% 98%;
        --border: 240 5.9% 90%;
        --input: 240 5.9% 90%;
        --ring: 240 5.9% 10%;
    }

    .dark:root {
        --background: 240 10% 3.9%;
        --foreground: 0 0% 98%;
        --card: 240 10% 3.9%;
        --card-foreground: 0 0% 98%;
        --popover: 240 10% 3.9%;
        --popover-foreground: 0 0% 98%;
        --primary: 0 0% 98%;
        --primary-foreground: 240 5.9% 10%;
        --secondary: 240 3.7% 15.9%;
        --secondary-foreground: 0 0% 98%;
        --muted: 240 3.7% 15.9%;
        --muted-foreground: 240 5% 64.9%;
        --accent: 240 3.7% 15.9%;
        --accent-foreground: 0 0% 98%;
        --destructive: 0 72% 51%;
        --destructive-foreground: 0 0% 98%;
        --border: 240 3.7% 15.9%;
        --input: 240 3.7% 15.9%;
        --ring: 240 4.9% 83.9%;
    }
}
`;

// src/commands/init.ts
var DEPENDENCIES = [
  "class-variance-authority",
  "clsx",
  "nativewind@^4.1.23",
  "tailwindcss-animate",
  "tailwind-merge",
  "lucide-react-native",
  "react-native-reanimated",
  "react-native-svg",
  "@rn-primitives/types",
  "@rn-primitives/slot",
  "@rn-primitives/portal"
];
var DEV_DEPENDENCIES = ["tailwindcss"];
var initOptionsSchema = z.object({
  cwd: z.string(),
  yes: z.boolean()
});
var init = new Command().name("init").description("initialize your project and install dependencies").option("-y, --yes", "skip confirmation prompt.", false).option(
  "-c, --cwd <cwd>",
  "the working directory. defaults to the current directory.",
  process.cwd()
).action(async (opts) => {
  try {
    const options = initOptionsSchema.parse(opts);
    const cwd = path.resolve(options.cwd);
    await runInit(cwd);
    logger.info(`${chalk2.green("Success!")}`);
  } catch (error) {
    handleError(error);
  }
});
async function runInit(cwd) {
  const spinner = ora(`Initializing project...`)?.start();
  await fs.writeFile(
    `${cwd}/tailwind.config.js`,
    TAILWIND_CONFIG,
    "utf8"
  );
  await fs.writeFile(
    `${cwd}/nativewind-env.d.ts`,
    NATIVEWIND_ENV,
    "utf8"
  );
  await fs.writeFile(`${cwd}/babel.config.js`, BABEL_CONFIG, "utf8");
  await fs.writeFile(`${cwd}/global.css`, GLOBAL_STYLES, "utf8");
  await fs.writeFile(`${cwd}/metro.config.js`, METRO_CONFIG, "utf8");
  const libDir = path.join(cwd, "lib");
  if (!existsSync(libDir)) {
    await fs.mkdir(libDir, { recursive: true });
  }
  await fs.writeFile(`${cwd}/lib/utils.ts`, UTILS, "utf8");
  spinner.succeed();
  const dependenciesSpinner = ora(`Installing dependencies...`)?.start();
  const packageManager = await getPackageManager(cwd);
  const packageCommand = packageManager === "npm" ? "install" : "add";
  await execa(packageManager, [packageCommand, ...DEPENDENCIES], { cwd });
  await execa(
    packageManager,
    [
      packageCommand,
      ...DEV_DEPENDENCIES,
      packageManager === "npm" ? "--save-dev" : "--dev"
    ],
    { cwd }
  );
  dependenciesSpinner?.succeed();
}

// src/commands/add.ts
import chalk3 from "chalk";
import { Command as Command2 } from "commander";
import { existsSync as existsSync2, promises as fs2 } from "fs";
import ora2 from "ora";
import path2 from "path";
import prompts from "prompts";
import * as z2 from "zod";
import { execa as execa2 } from "execa";

// src/utils/registry.ts
var ALL_COMPONENTS = [
  "Avatar",
  "Accordion",
  "Alert",
  "Badge",
  "Button",
  "Card",
  "Checkbox",
  "Input",
  "Label",
  "Progress",
  "RadioGroup",
  "Separator",
  "Skeleton",
  "Switch",
  "Text",
  "Textarea",
  "Toggle",
  "Typography",
  "Tabs",
  "DropdownMenu"
];
var baseUrl = "https://raw.githubusercontent.com/unisol1020/nativecn/main";
var COMPONENT_METADATA = {
  Avatar: {
    name: "Avatar",
    dependencies: ["@rn-primitives/avatar"]
  },
  Accordion: {
    name: "Accordion",
    dependencies: ["@rn-primitives/accordion"]
  },
  Checkbox: {
    name: "Checkbox",
    dependencies: ["@rn-primitives/checkbox"]
  },
  Label: {
    name: "Label",
    dependencies: ["@rn-primitives/label"]
  },
  Progress: {
    name: "Progress",
    dependencies: ["@rn-primitives/progress"]
  },
  RadioGroup: {
    name: "RadioGroup",
    dependencies: ["@rn-primitives/radio-group"]
  },
  Separator: {
    name: "Separator",
    dependencies: ["@rn-primitives/separator"]
  },
  Switch: {
    name: "Switch",
    dependencies: ["@rn-primitives/switch"]
  },
  Tabs: {
    name: "Tabs",
    dependencies: ["@rn-primitives/tabs"]
  },
  Toggle: {
    name: "Toggle",
    dependencies: ["@rn-primitives/toggle"]
  },
  DropdownMenu: {
    name: "DropdownMenu",
    dependencies: ["@rn-primitives/dropdown-menu"]
  }
};
async function fetchComponents(components) {
  try {
    return await Promise.all(
      components.map(async (component) => {
        const response = await fetch(
          `${baseUrl}/packages/ui/src/${component}.tsx`
        );
        const content = await response.text();
        return {
          name: `${component}.tsx`,
          content,
          metadata: COMPONENT_METADATA[component] || { name: component }
        };
      })
    );
  } catch (error) {
    console.error(error);
    throw new Error(`Failed to fetch components from registry.`);
  }
}

// src/commands/add.ts
var addOptionsSchema = z2.object({
  components: z2.array(z2.string()).optional(),
  yes: z2.boolean(),
  overwrite: z2.boolean(),
  cwd: z2.string(),
  all: z2.boolean(),
  path: z2.string().optional()
});
var add = new Command2().name("add").description("add a component to your project").argument("[components...]", "the components to add").option("-y, --yes", "skip confirmation prompt.", true).option("-o, --overwrite", "overwrite existing files.", false).option(
  "-c, --cwd <cwd>",
  "the working directory. defaults to the current directory.",
  process.cwd()
).option("-a, --all", "add all available components", false).option("-p, --path <path>", "the path to add the component to.").action(async (components, opts) => {
  try {
    const options = addOptionsSchema.parse({
      components,
      ...opts
    });
    const cwd = path2.resolve(options.cwd);
    if (!existsSync2(cwd)) {
      logger.error(`The path ${cwd} does not exist. Please try again.`);
      process.exit(1);
    }
    let selectedComponents = options.all ? ALL_COMPONENTS : options.components;
    if (!options.components?.length && !options.all) {
      const { components: components2 } = await prompts({
        type: "multiselect",
        name: "components",
        message: "Which components would you like to add?",
        hint: "Space to select. A to toggle all. Enter to submit.",
        instructions: false,
        choices: ALL_COMPONENTS.map((component) => ({
          title: component,
          value: component
        }))
      });
      selectedComponents = components2;
    }
    if (!selectedComponents?.length) {
      logger.warn("No components selected. Exiting.");
      process.exit(0);
    }
    if (!options.yes) {
      const { proceed } = await prompts({
        type: "confirm",
        name: "proceed",
        message: `Ready to install components and dependencies. Proceed?`,
        initial: true
      });
      if (!proceed) {
        process.exit(0);
      }
    }
    const payload = await fetchComponents(selectedComponents);
    const spinner = ora2(`Installing components...`).start();
    const dependencies = /* @__PURE__ */ new Set();
    for (const item of payload) {
      if (item.metadata.dependencies) {
        item.metadata.dependencies.forEach((dep) => dependencies.add(dep));
      }
    }
    if (dependencies.size > 0) {
      spinner.text = `Installing component dependencies...`;
      const packageManager = await getPackageManager(cwd);
      const packageCommand = packageManager === "npm" ? "install" : "add";
      await execa2(
        packageManager,
        [packageCommand, ...Array.from(dependencies)],
        { cwd }
      );
      spinner.succeed(`Component dependencies installed.`);
      spinner.start(`Installing components...`);
    }
    for (const item of payload) {
      spinner.text = `Installing ${item.name}...`;
      const targetDir = options.path ? path2.resolve(cwd, options.path) : `${cwd}/components`;
      if (!targetDir) {
        continue;
      }
      if (!existsSync2(targetDir)) {
        await fs2.mkdir(targetDir, { recursive: true });
      }
      const existingComponent = existsSync2(
        path2.resolve(targetDir, item.name)
      );
      if (existingComponent && !options.overwrite) {
        if (selectedComponents.includes(item.name.slice(0, -4))) {
          spinner.stop();
          const { overwrite } = await prompts({
            type: "confirm",
            name: "overwrite",
            message: `Component ${item.name} already exists. Would you like to overwrite?`,
            initial: false
          });
          if (!overwrite) {
            logger.info(
              `Skipped ${item.name}. To overwrite, run with the ${chalk3.green(
                "--overwrite"
              )} flag.`
            );
            continue;
          }
          spinner.start(`Installing ${item.name}...`);
        } else {
          continue;
        }
      }
      const filePath = path2.resolve(targetDir, item.name);
      await fs2.writeFile(filePath, item.content);
    }
    spinner.succeed(`Done.`);
  } catch (error) {
    handleError(error);
  }
});

// src/index.ts
function main() {
  const program = new Command3();
  program.name("nativecn").description("add components and dependencies to your expo project").version("1.2.0");
  program.addCommand(init);
  program.addCommand(add);
  program.parse(process.argv);
}
main();
//# sourceMappingURL=index.js.map